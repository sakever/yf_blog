---
title: 网络安全相关
date: 2023-08-17
sidebar: true
categories:
  - 计算机网络
tags:
  - 网络安全
---
## 常见网络攻击
### XSS 攻击
在写后端代码时，公司的自动检测对某个方法报了如下警告：

发现了潜在的 XSS。它可用于在客户端的浏览器中执行不需要的 JavaScript

易受攻击的代码：
```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp)  {
    String input1 = req.getParameter("input1");
    ......
    resp.getWriter().write(input1);
}
```
如何避免这种情况：
```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
    String input1 = req.getParameter("input1");
    ......
    resp.getWriter().write(Encode.forHtml(input1));
}
```
Encode.forHtml 方法就是对 html 的元素做转义，比如 < 转义为 &lt; 等

一时兴起了解了一下 xss 的相关概念，防御 xss 攻击通常需要考虑 4 种情况： HTML、JavaScript、CSS（样式）和 URL。可以看到 xss 是针对前端页面的攻击
#### XSS 是什么
Xss 即（Cross Site Scripting）中文名称为：跨站脚本攻击。XSS 的重点不在于跨站点，而在于脚本的执行

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接**在用户的终端**执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求

XSS 有以下几种分类：

- 反射型：指的是攻击者在 url 的链接后面的参数中加入恶意攻击代码。当用户打开带有恶意代码的 URL 的时候，网站服务端将恶意代码从 URL 中取出，拼接在 html 中并且返回给浏览器端
- 存储型：主要是将恶意代码上传或存储到服务器中，下次只要受害者浏览包含此恶意代码的页面就会执行恶意代码。上面的示例中，防御的就是储存型的 XSS

我们知道了利用 xss 可以在页面上实现一些奇怪的效果，比如改个样式、输出一些数据等等，那黑客到底可以通过 xss 做什么呢？

- 通过 document.cookie 盗取 cookie 使用 js 或 css 破坏页面正常的结构与样式流量劫持
- Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应
- 利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作
- 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动
- DOS（拒绝服务）客户端浏览器。钓鱼攻击，高级的钓鱼技巧
- 劫持用户 Web 行为，甚至进一步渗透内网
- 蠕虫式挂马攻击、刷广告、刷浏量、破坏网上数据
#### Xpath 注入
XPath 是一种用来在内存中导航整个 XML 树的语言，它使用路径表达式来选取 XML 文档中的节点或者节点集。你可以将它理解成查询 XML 文件的 SQL，Xpath 注入也与 SQL 注入类似，如下图，传入类似 ’ or 1=1 or ”=’ 的值，将返回所有用户的列表
![XPath注入示例](/docs/.vuepress/public/xpath-injection.png)

对于此类的注入，参数化查询是不错的选择，将需要构建的 XPath 查询表达式，以变量的形式表示，变量不是可以执行的脚本
#### 如何防御 XSS
我们可以从 XSS 攻击的两个过程中去防御：

1，攻击者提交恶意代码

- 对输入的内容诸如 <script>、<img>、<a> 等标签进行过滤
- 编码转移。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果

2，浏览器执行恶意代码

- Cookie 的安全设置，HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie
- 开启 CSP 网页安全政策

### SQL 注入
大部分后端开发者所学习到的第一个漏洞，我们在学习 mybatis 时老师肯定提过一嘴 sql 注入相关概念。其实除了 sql 注入还有命令注入，Host 头注入等其他注入方式，不过它们都大同小异
#### 什么是 SQL 注入
应用程序中只要是与数据库有数据交互的地方，无论是增删改查，如果数据完全受用户控制，而应用程序又处理不当，那么这些地方都是可能存在 SQL 注入的

比如现在我们用代码实现了一段 sql
```java
// 重密码输入: ' OR '1'='1时，等同于不需要密码
String sql = "SELECT * FROM t_user WHERE username='"+userName+"' AND pwd='"+password+"'";
```
这里的代码本来想实现下面的查询：
```sql
SELECT * FROM t_user WHERE username = 'adc' AND pwd = 'adcspassword'
```
但是我们可以输入一些奇怪的参数，让 sql 执行原来不可能的行为。比如输入 ‘ OR 1 = 1
```sql
SELECT * FROM t_user WHERE username = 'adc' AND pwd = '' OR 1 = 1
```
这条 sql 就变成了查询所有的用户信息

在代码中直接进行字符串拼接的时候就会出现这种情况

#### 防御 SQL 注入
1，使用预编译处理输入参数：要防御 SQL 注入，用户的输入就不能直接嵌套在 SQL 语句当中。使用参数化的语句，用户的输入就被限制于一个参数当中。比如上一个例子中，黑客输入‘ OR 1 = 1 时，我们将其塞进参数中，就会变成这样
```sql
SELECT * FROM t_user WHERE username = 'adc' AND pwd = '\' OR 1 = 1'
```

2，输入验证：检查用户输入的合法性，以确保输入的内容为正常的数据。数据检查应当在客户端和服务器端都执行，之所以要执行服务器端验证，是因为客户端的校验往往只是减轻服务器的压力和提高对用户的友好度，攻击者完全有可能通过抓包修改参数或者是获得网页的源代码后，修改验证合法性的脚本（或者直接删除脚本），然后将非法内容通过修改后的表单提交给服务器等等手段绕过客户端的校验。因此，要保证验证操作确实已经执行，唯一的办法就是在服务器端也执行验证。但是这些方法很容易出现由于过滤不严导致恶意攻击者可能绕过这些过滤的现象，需要慎重使用

3，错误消息处理：防范 SQL 注入，还要避免出现一些详细的错误消息，恶意攻击者往往会利用这些报错信息来判断后台 SQL 的拼接形式，甚至是直接利用这些报错注入将数据库中的数据通过报错信息显示出来

4，加密处理：将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令

### CSRF 攻击
CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。又叫 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法
#### 什么是 CSRF
举个例子：

A 网站通过 cookie 来识别用户（C），当用户成功进行身份验证之后浏览器就会得到一个标识其身份的 cookie，只要不关闭浏览器或者退出登录，以后访问 A 网站（准确的说，是同次级域名下的网站）会一直带上这个 cookie

如果这期间浏览器被人控制着向 A 网站发起请求去执行一些用户不想做的功能（比如添加账号），这就是会话劫持了

具体操作就是，黑客先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=c&amount=1000000&for=hanker”（向浏览器请求给 hanker 转账1000000 元），并且通过广告等诱使 C 来访问他的网站。当 C 访问该网站时，根据服务器返回的响应，上述 url 就会从 C 的浏览器发向银行，而这个请求会附带 C 浏览器中的 cookie 一起发向银行服务器

因为这个不是用户真正想发出的请求，这就是所谓的**请求伪造**。此外，由于请求可以从第三方网站提交，所以加上前缀**跨站**二字，即从 B 网站发起

注意黑客是无法获取用户的 cookie 的，因为 cookie 存放在本地，而黑客的服务器是用户访问的
#### 如何防御 CSRF
根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址

在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件

这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站

因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求
### DDoS
全程分布式拒绝服务攻击，DDoS 是一种基于 DoS 的特殊形式的拒绝服务攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。与 DoS 攻击由单台主机发起攻击相比较，分布式拒绝服务攻击 DDoS 是借助数百、甚至数千台被入侵后安装了攻击进程的主机同时发起的集团行为

一个完整的 DDoS 攻击体系由攻击者、主控端、代理端和攻击目标四部分组成。主控端和代理端分别用于控制和实际发起攻击，其中主控端只发布命令而不参与实际的攻击，代理端发出 DDoS 的实际攻击包。对于主控端和代理端的计算机，攻击者有控制权或者部分控制权．它在攻击过程中会利用各种手段隐藏自己不被别人发现

真正的攻击者一旦将攻击的命令传送到主控端，攻击者就可以关闭或离开网络．而由主控端将命令发布到各个代理主机上。这样攻击者可以逃避追踪。每一个攻击代理主机都会向目标主机发送大量的服务请求数据包，这些数据包经过伪装，无法识别它的来源，而且这些数据包所请求的服务往往要消耗大量的系统资源，造成目标主机无法为用户提供正常服务。甚至导致系统崩溃

CC 攻击（Challenge Collapsar，直译为**挑战黑洞**）是一种针对 Web 应用层的 DDoS，主要通过模拟大量合法用户的 HTTP 请求，耗尽服务器资源（如CPU、内存、数据库连接等），导致正常用户无法访问服务。**CC 的主要攻击层是应用层，攻击方式为模拟用户请求（如刷 API、爬虫），而传统 DDoS 攻击层是网络层，攻击方式为发送垃圾数据包（如 SYN 洪水）**
## 加密和签名
对一段明文进加密，只有用指定的密钥才能解密，防止数据被窃取，泄漏。**加密算法是将普通的文本与一串数字的结合，产生不可理解的密文的步骤**

**公钥和私钥都可以用于加密数据，但是只能用与之对应的密钥解密数据**。使用公钥加密还是私钥加密取决于你想要对数据加密还是签名

在公钥加密系统中，发送者使用接收者的**公钥**来加密数据，然后接收者使用自己的私钥来解密数据。这种方式可以确保只有接收者能够解密数据，因为私钥只有接收者拥有。公钥加密系统通常用于安全地传输数据，确保只有授权的接收者能够解密和阅读数据

签名则是指对一段明文进行签名，通过指定的密钥来验证签名，**防止数据被篡改**。数字签名是一种用于验证数据完整性和来源的技术，它使用公钥和私钥配对来实现

在数字签名过程中，数据发送者使用自己的**私钥**对**数据的哈希值**进行签名（加密，因为加密过程比较慢，对哈希值加密会比较快），然后接收者可以使用发送者的公钥来验证签名的有效性，即解密签名并且查看解密后的哈希值和发送过来的未加密内容的哈希值是否一致

这样可以确保数据的完整性和真实性，因为只有拥有发送者私钥的人才能够生成有效的签名。签名的本意是为了防止数据被篡改，因此我们一般对信息内容追加签名，即签名和原本的信息会一起发送给服务器
### RSA2
SHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，属于 SHA 算法之一，是 SHA-1 的后继者

现在有很多可以生成 RSA2 的程序，生成后会拿到一个公钥和一个私钥，我们只能把公钥放到互联网上
## 摘要算法
摘要算法是经过一系列计算，将大量的0和1转换成少量的0和1

消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，无论输入的消息有多长，计算出来的消息摘要的长度总是固定的

目前可以解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在密钥的管理与分发问题，适合于分布式网络上使用
### MD5
MD5 的作用是让大容量信息在用数字签名软件签署私人密钥前被压缩成一种保密的格式 (也就是把一个任意长度的字节串变换成一定长的十六进制数字串)，具有以下特点

- 压缩性 : 任意长度的数据，算出的 MD5 值长度都是固定的
- 容易计算 : 从原数据计算出 MD5 值很容易
- 抗修改性 : 对原数据进行任何改动，哪怕只修改1个字节，所得到的 MD5 值都有很大区别
- 强抗碰撞 : 已知原数据和其 MD5 值，想找到一个具有相同 MD5 值的数据（即伪造数据）是非常困难的
