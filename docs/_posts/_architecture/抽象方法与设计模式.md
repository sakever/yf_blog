---
title: 抽象方法与设计模式
date: 2024-03-01
sidebar: ture
categories:
  - 架构设计
tags:
  - 设计模式
---
真正的屎山不是初级程序员写的巨量胶水代码，而是没学明白抽象的程序员写的大量设计模式耦合形成的。你甚至不理解为什么当初的创作者需要使用到这个设计模式，不知道从哪开始读之前的代码，甚至在心中咒骂之前的作者无数遍。为了不让我们的后者觉得我们的水平很差，学好设计模式是很重要的

设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决**思路**。设计模式一般分为这三大类：

- 创建型模式：关注于对象的创建机制，提供了创建对象的灵活性，代表为工厂、原型、单例、建造者。这些在平时编码的时候应该会经常遇到
- 结构型模式：结构型模式关注于如何将类或对象组合成更大的结构，比如代理模式（AOP）、过滤器模式、适配器模式（防腐层、仓储层）等
- 行为型模式：关注于对象之间的通信、交互，比如状态、策略、模板、责任链模式、观察者模式等

本文会列出几个常用框架以及 jdk 中使用的设计模式
## 设计模式的六大原则
1、开闭原则

**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，**尽量不要重构代码**，除非是你自己负责编写的业务。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类

2、里氏代换原则（Liskov Substitution Principle）LSP

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现

3、依赖倒转原则

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体

4、接口隔离原则

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度

5、迪米特法则，又称最少知道原则

一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立

6、合成复用原则

尽量使用合成或者聚合的方式，而不是使用继承

简单来说，上面几点就是：减少耦合、多用抽象、少改上线后的代码
## 工厂模式
工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

工厂模式提供了一种创建对象的方式，而无需指定要创建的具体类。工厂模式属于创建型模式，它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离

定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。使用工厂模式的好处与场景如下：

- 主要解决接口选择的问题，同时也可以**将客户端代码与对象的创建过程分离开**
- **我们明确地计划不同条件下创建不同实例时可以使用这种模式**
- 这里的不同条件应当是调用我们系统的人或者使用我们框架的人给定的。如果这里的不同的条件是由我们系统自身给与的，那就没必要使用设计模式

这里的场景必须全部满足才可以用，因为在我读过的业务代码中，正确的例子没几个，错误的使用倒是不少

mybatis 使用了这种模式。因为我们可能会接入很多不同类型的 jdbc，比如 MySQL、orical、pg 等，而且这些数据库都是我们配置的而非 mybatis 框架配置的，一个数据库的配置信息，对应一个 SqlSessionFactory。SqlSessionFactory 工厂生成的 SqlSession，就是一个个链接请求
## 单例模式
单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例，注意：

- 单例类只能有一个实例
- 单例类必须自己创建自己的唯一实例
- 单例类必须给所有其他对象提供这一实例

我们大名鼎鼎的 Spring 中的 IOC 就使用了单例模式。IOC 容器会将所有被打上 bean 标签的类创建一个单例对象，并且存放在容器内
## 建造者模式
建造者模式（Builder Pattern，又叫生成器模式）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的，我们用 builder 的目的多是因为这个类参数太多，我们用构造方法无法很好的创造它

建造者模式在代码中天天被用到，我已经忘了建造者模式的代码怎么写了，因为 lombak 中的 @Builder 注解将该模式包装的太好了。我们随便找个用了 @Builder 的 POJO 反编译一下就可以看见建造者模式的源码了
## 过滤器模式
过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组数组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准

简单来说就是将过滤的代码拆分到不同的方法中，在使用的时候组合起来

听起来是不是有点抽象，事实上我们天天都在用，就是 stream 中的 filter：
```java
public class FilterPatternDemo {
    public static void main(String[] args) {
        List<Person> persons = Arrays.asList(
            new Person("Robert", "Male", 30),
            new Person("John", "Male", 25),
            new Person("Laura", "Female", 22),
            new Person("Diana", "Female", 28)
        );

        System.out.println("Males: ");
        persons.stream().filter(PersonFilter::filter).forEach(System.out::println);

        System.out.println("Males and Age >= 25: ");
        persons.stream().filter(PersonFilter::filter).filter(Age25Filter::filter).forEach(System.out::println);
}
```
## 装饰器模式
装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装

装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能

我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类

这个模式还是很有用的，有时候我们接受的一个 dubbo 对象中，需要对其中加几个属性，我们就可以构造一个子类对象，将属性加到子类中

## 享元模式
享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式

享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象

比如德鲁伊、以及 jdk 中的线程池，就使用了这种模式。他们的共性是使用一个池子维护的一堆对象，有些可能会使用一个 key 来快速查找对象，比如 IOC 容器
## 责任链模式
顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式

在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推

mvc 中的拦截器使用了责任链模式
## 模板模式
在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式

AQS 组件使用了模板模式，一个超级简单的模板模式如下：

```java
public abstract class AbstractCrudOperationStrategy<T> {
    public void doOperation(OperationResult ret) {
            beforeOperation(ret);
            operation(ret);
            postOperation(ret);
    }
}
```