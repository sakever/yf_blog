---
title: 参数校验与异常处理
date: 2023-04-03
sidebar: ture
categories:
  - 架构设计
tags:
  - 参数校验
  - 异常处理
---
# 参数校验
对传入后端的数据再检查是否合法的刚才叫参数校验，这么做是为了避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据

javax.validation，JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验在项目中导入该依赖以启动 JSR 功能
```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
```
或者这个
```xml
    <dependency>
      <groupId>javax.validation</groupId>
      <artifactId>validation-api</artifactId>
    </dependency>
```

## JSR 是什么

Java 社区过程（JCP）是国际 Java 社区标准化和批准 Java 技术规范的一个过程，简而言之，是一个开放的国际组织

JCP 采用包容性、基于共识的方法确保高质量规范的开发。JCP 批准的规范必须附带参考实现（以证明规范可以实现）和技术兼容性套件（一套用于测试实现是否符合规范的测试、工具和文档，称为技术兼容性套件）。而这些通过了测试的提案，就被称为 JSR

## 常用的 JSR 注解校验注解
Validation-API|	概述
-|-
@AssertFalse|	被注释的元素必须为 false
@AssertTrue|	被注释的元素必须为 true
@DecimalMax|	被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@DecimalMin|	被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Digits	|被注释的元素必须是一个在可接受范围内的数字
@Email|	被注释的元素必须是正确格式的电子邮件地址
@Future|	被注释的元素必须是将来的日期
@FutureOrPresent|	被注释的元素必须是现在或将来的日期
@Max	|被注释的元素必须是一个数字，其值必须小于等于指定的最大值
@Min	|被注释的元素必须是一个数字，其值必须大于等于指定的最小值
@Negative	|被注释的元素必须是一个严格的负数（0为无效值）
@NegativeOrZero	|被注释的元素必须是一个严格的负数（包含0）
@NotBlank	|被注释的元素同StringUtils.isNotBlank，只作用在String上，在String属性上加上@NotBlank约束后，该属性不能为null且trim()之后size>0
@NotEmpty	|被注释的元素同StringUtils.isNotEmpty，作用在集合类上面，在Collection、Map、数组上加上@NotEmpty约束后，该集合对象是不能为null的，并且不能为空集，即size>0
@NotNull	|被注释的元素不能是Null，作用在Integer上（包括其它基础类），在Integer属性上加上@NotNull约束后，该属性不能为null，没有size的约束；@NotNull作用在Collection、Map或者集合对象上，该集合对象不能为null，但可以是空集，即size=0（一般在集合对象上用@NotEmpty约束）
@Null	|被注释的元素元素是Null
@Past	|被注释的元素必须是一个过去的日期
@PastOrPresent|	被注释的元素必须是过去或现在的日期
@Pattern	|被注释的元素必须符合指定的正则表达式
@Positive|	被注释的元素必须严格的正数（0为无效值）
@PositiveOrZero|	被注释的元素必须严格的正数（包含0）
@Szie	|被注释的元素大小必须介于指定边界（包括）之间

上面的每个注解可以加入 message，在抛出异常的时候会自动设置 message
```java
    @NotNull(message = "前端漏传参数")
```
## 如何使用
在 POJO 中加完 jsr 303 之后，需要启动才可以使用。在**入参**中使用 @Valid 或者 @Validated 注解开启校验
```java
    @PostMapping("/person")
    public ResponseEntity<Person> getPerson(@RequestBody @Valid Person person) {
        return ResponseEntity.ok().body(person);
    }
```
我们在需要验证的参数上加上 @Valid 注解，如果验证失败，它将抛出 MethodArgumentNotValidException。默认情况下，Spring 会将此异常转换为 HTTP Status 400（错误请求）。记得接住这个异常处理一下，不然前端会收到一堆奇怪的文本

如果传入不是 POJO 的话，可以直接加在入参上。同样可以生效，并且不止控制层，在 service 层上加也会生效
```java
    @Override
    public void afterConnectionClosed(@NotNull WebSocketSession session, @NotNull CloseStatus status) throws Exception {
        log.debug("websocket 已关闭.............");
        Monitor.count("websocket.connection-closed");
        super.afterConnectionClosed(session, status);
    }
```

注意 @Validated 是用于开启 Spring 的参数校验功能，只有入参为 POJO 时才会校验实体中被 JSR303 制定的校验注解注释的字段
```java
    @GetMapping("/test")
    public Object test(@RequestParam("a") @Validated @Pattern(regexp = "[1-9]", message = "aaaaaaaa") String a) {
        return a + "success";
    }
```
如果你想直接校验并且拿到错误信息，做一些处理，自然也是可以的：
```java
    public static <T> String validateEntity(T obj) {
        StringBuilder result = new StringBuilder();
        Set<ConstraintViolation<T>> set = VALIDATOR.validate(obj, Default.class);
        if (set != null && !set.isEmpty()) {
            for (ConstraintViolation<T> cv : set) {
                //拼接错误信息
                result.append(" ").append(cv.getMessage());
            }
        }
        return result.toString();
    }
```

## @Valid 和 @Validated 区别
@Valid 属于 javax.validation 包下，作为标准 JSR-303 规范，还没有吸收分组的功能。该注解可以用在方法、构造函数、方法参数和成员属性（字段）上

@Validated Spring 的 JSR-303 规范，是标准 JSR-303 的一个变种，提供了一个分组功能，可以在入参验证时，根据不同的分组采用不同的验证机制。该注解可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上

## 什么时候应该用参数校验
这是类似最佳实践的东西，其实有时候就算不进行参数校验也不会影响程序的正确性，如果是查询条件的话顶多在数据库查不到数据，如果是增删改接口的话可能需要满足一些额外条件

- 在需要插入一定条件数据的时候可以加，比如要求输入身份证号、电话号码等
- 条件不能非空、不能为 null 的时候
- 日期考虑一下能不能存放未来的日期
- 对一些限制比较严格的输入，比如要求输入枚举类，可以不加参数校验

## 分组校验
@Validated 使用 class 来区分组别

第一步、定义一个校验组类，声明四个接口对应不同场景校验
```java
public class ValidationGroups {
    public interface Update {
    }

    public interface Insert {
    }

    public interface Detail {
    }
  
    public interface Delete{
    }
}
```
第二步、在实体类具体属性添加校验规则及校验分组
```java
        @NotNull(message = "渠道id 不能为空",groups ={ValidationGroups.Detail.class,ValidationGroups.GetList.class,ValidationGroups.Update.class})
        private Integer regionId;
```
第三步、在控制层 @Validated 注解后添加具体校验的分组名，注意：

- 如果没有设置分组，会被划分到默认分组
- 如果设置了分组，会将该属性从默认分组中移除
- 一个属性可以设置多个分组
# 嵌套验证参数
```java
public class Item{
    @NotNull(message = "操作人 不能为空")
    private String operator;
 
    @NotNull(message = "操作时间 不能为空")
    private LocalDateTime operationTime;
 
    @NotBlank(message = "移动类型不能为空")
    private String moveTypeId;
 
    @NotEmpty(message = "所需移动的物料信息不能为空")
    private List<Prop> props;
}

public class Prop{
    @NotNull(message = "物料编号不能为空")
    private String materialId;
   
    @NotNull(message = "规格编号不能为空")
    private String specId;
 
    @NotNull(message = "物料数量不能为空")
    @DecimalMin(value="0",message="数量不能小于0")
    private Double quantity;
}
```
如果 Item 实体的 props 属性不加 @Valid注释，只有 @NotNull 或 @NotBlank，无论 controller 层入参方法上采用 @Validated 还是 @Valid 验证，Spring Validation 框架只会对 Item 实体类上的的 operator、operationTime 和 moveTypeId 这三个属性做非空或数量验证。不会对 props 字段里的 Prop 实体类中的属性字段进行验证

也就是说，controller 层方法入参上加 @Validated 或 @Valid，实际运行上并不会自动对参数进行嵌套验证

想要实现嵌套验证参数，必须手动在 Item 实体的 props 字段上明确指出，Item 实体中的哪些字段（如 props）里面的属性也要进行验证

由于 @Validated 不能用在成员属性（字段）上，但是 @Valid 能加在成员属性（字段）上，而且 @Valid 类注解上也说明了它支持嵌套验证功能

因此需要在嵌套验证类的相应字段上加上 @Valid 注解，并配合 controller 层入参方法参数上，加上 @Validated 或 @Valid 注解来进行嵌套验证
# 统一异常处理
参数校验失败后会抛出异常，我们可以用 try - catch 来处理异常，不过这样的代码过于繁琐，需要优化

并且，控制层上参数校验的是无法在函数内 catch 到的，我们需要一种全局化的方式
## @ExceptionHandler
**为每个控制器添加各自处理异常的注解**：Spring 提供了异常处理相关的注解 @ExceptionHandler，从字面上看，就是异常处理器的意思，其实际作用是若在某个 Controller 类定义一个异常处理方法，并在方法上添加该注解，那么当出现指定的异常时，会执行该处理异常的方法，其可以使用 springmvc 提供的数据绑定，比如注入 HttpServletRequest 等，还可以接受一个当前抛出的 Throwable 对象

```java
@RestController
@Validated
@RequestMapping("/api/studentCodeReading")
@Slf4j
public class StudentCodeReadingController {

	......
	
	@ExceptionHandler(Exception.class)
	private ApiResult<Object> exceptionHandler(Exception e) {
		log.error("系统错误: {}", e);
		return Result.error(e.getMessage());
	}
}
```
但是，这样一来，就必须在每一个 Controller 类都定义一套这样的异常处理方法，因为异常可以是各种各样。这样一来，就会造成大量的冗余代码，而且若需要新增一种异常的处理逻辑，就必须修改所有 Controller 类了，很不优雅。在 Controller 层处理异常需要一些特殊手段
## @ControllerAdvice
使用 **ControllerAdvice 注解**对 Controller 层进行扫描，该注解可以把异常处理器应用到所有控制器，而不是单个控制器。借助该注解，我们可以实现：在独立的某个地方，比如单独一个类，定义一套对各种异常的处理机制，然后在类的签名加上注解 @ControllerAdvice，统一对不同阶段的、不同异常进行处理。这就是统一异常处理的原理

ControllerAdvice 注解中的 assignableTypes 属性可以指定被选择的类（一般不指定）。该类是为那些声明了 @ExceptionHandler、@InitBinder 或 @ModelAttribute 注解修饰的方法的类而提供的

ExceptionHandler 注解指定拦截哪些异常对象，在方法中做具体处理，同时一般在方法或者类上加入 @ResponseBody 注解来返回 JSON 数据
```java
@ControllerAdvice//(assignableTypes = {})
@ResponseBody
@Slf4j
public class BusinessExceptionHandler {

    /**
     * 一般情况下一个方法特定处理一种异常
     * @param e
     * @return 一个错误的统一结果，或者什么都不返回
     */
    @ExceptionHandler(Exception.class)
    public Result exceptionHandler(Exception e) {
    	log.error("系统错误: {}", e);
		return Result.error(e.getMessage());
    }
}
```
对于 jsr303 校验后的返回，应当使用特定的方式向前端返回，不然返回的结果没人看得懂。同时，在异常拦截器下，我们还可以捕获多个异常，进行特殊处理，最重要的是，每个异常都应该打上监控报警，让我们及时发现系统里的问题
```java
	@ResponseBody
    @ExceptionHandler(Exception.class)
    public JsonResult globalException(Exception ex) {
        if (ex instanceof BusinessException) {
        	// 这是一个打点方法，记录异常的 NAME_SPACE、url、告警级别和异常 message
        	perf(PerfConstants.NAME_SPACE, PerfConstants.PERF_API_AOP_TAG, HttpUtils.getUrl(), e.getMessage(), ExceptionLevelEnum.INFO);
            return JsonResult.error(ex.getMessage());
        }
        
        if (ex instanceof MethodArgumentNotValidException) {
            perf(PerfConstants.NAME_SPACE, PerfConstants.PERF_API_AOP_TAG, HttpUtils.getUrl(), e.getMessage(), ExceptionLevelEnum.WARN);
            return JsonResult.error(((MethodArgumentNotValidException) ex).getBindingResult().getFieldError().getDefaultMessage());
        }
        // 这个日志之前记录我们不需要关注的异常，这个日志之后记录需要关注的异常
        log.error("异常:", ex);

        if (ex instanceof DataSyncException) {
            perf(PerfConstants.NAME_SPACE, PerfConstants.PERF_API_AOP_TAG, HttpUtils.getUrl(), e.getMessage(), ExceptionLevelEnum.ERROR);
            return JsonResult.error(((MethodArgumentNotValidException) ex).getBindingResult().getFieldError().getDefaultMessage());
        }
        
        perf(PerfConstants.NAME_SPACE, PerfConstants.PERF_API_AOP_TAG, HttpUtils.getUrl(), e.getMessage(), ExceptionLevelEnum.ERROR);
		// 这里不对用户保留失败原因
        return JsonResult.error(EnvironmentUtil.isDevOrBeta() ? ex.getMessage() : "系统异常");
    }
```