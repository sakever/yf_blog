---
title: 面试常见算法总结
date: 2025-03-05
sidebar: true
categories:
  - 数据结构与算法
tags:
  - 算法
  - 数据结构
---
## 图
图，静态连通性问题，都可以使用 DFS 或者 BFS 或者并查集解决

一定要记录一个对应的 bool 数组，bool 数组是用来判断是否要进行下一次搜索逻辑的，是用来记录本次已经搜索过该节点记录的
## 排序

排序算法时空复杂度

排序方法|时间复杂度|空间复杂度
-|-|-
冒排、插排、选排|n^2|1
快排|nlogn|logn
二分|nlogn|n
堆排|nlogn|1

一些题目可能会使用到排序，比如[最小数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/?envType=study-plan-v2&envId=top-interview-150)

下面这个小技巧在很多题目中应该都用到了，java 中关于二维数组排序方法：Arrays.sort(meetings, Comparator.comparingInt(x -> x[2]));
## 投票法
[多数元素](https://leetcode.cn/problems/majority-element/?envType=study-plan-v2&envId=top-interview-150)，投票法找众数，遇到众数加一，没遇到减一
## DP
这位更是重量级，难点是看状态转移方程，思路为想**如果现在拼到了最后一步，上一步是谁**
需要枚举每一种情况时使用，并且每一种情况对后续考虑有帮助时使用

[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-interview-150)
[环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/?envType=study-plan-v2&envId=top-interview-150)
[交错字符串](https://leetcode.cn/problems/interleaving-string/?envType=study-plan-v2&envId=top-interview-150)，这题目更加麻烦，属于二维 DP

## 分发糖果，接雨水
属于数组的难题，需要考虑左右边，具体解法是左右各遍历一次，记录每个位置的左边最大值和右边最大值方便为 A 和 B，然后遍历数组中每个元素时，取 A、B 中较小的那个，减去当前高度，就是当前位置的接水量

## 双指针
[三数之和](https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-interview-150)，数据有序时，可能会用到

## 滑动窗口，双指针进阶版
[无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-interview-150)，记得用 for+while 的格式写代码
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                // 不断地移动右指针
                occ.add(s.charAt(rk + 1));
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}
```
## 二叉树
要么是递归，要么是层序遍历，都挺简单的

## 回溯
递归
## 分治
也是递归，注意，迭代左右边数据的时候，需要加一减一

## 位运算
考验异或操作 ^ 按位与 & 按位或 |

只出现一次的数字 II：答案的第 i 个二进制位就是数组中所有元素的第 i 个二进制位之和除以 3 的余数

## 链表
重点就是你需要用很多指针，记录 start、end、pre、cur、next 等节点。一个很经典的题目就是反转链表，至少这题的代码需要背下来

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```