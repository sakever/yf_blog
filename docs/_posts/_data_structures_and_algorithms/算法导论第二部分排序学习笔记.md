--- 
title: 算法导论第二部分排序学习笔记
date: 2022-11-03

categories:
  - 数据结构与算法
tags:
  - 排序
--- 
三种比较基本的排序算法：冒泡排序、选择排序（像给牌堆中的扑克牌排序一样，将之后的牌放在已经拍好序的牌堆里）、比较排序（只选择牌堆中的最大的牌放入已经排好序的牌堆后方），比较简单并且所提供的时间复杂度很高（O(n^2)），没有什么研究的意义，让我们直接从堆排序开始

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/e927a18a6c6cce93212a83bce399113e.png)
# 堆排序
堆是一棵完全二叉树（不一定是满二叉树），每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆

一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)
## 算法思想
1，将待排序的序列构造成一个最大堆（此操作只要不停调用维持堆性质的函数即可），此时序列的最大值为根节点
2，依次将根节点与待排序序列的最后一个元素交换
3，再维护从根节点到该元素的前一个节点为最大堆，如此往复，最终得到一个递增序列
```java
class Solution {

    int[] heap;

    public int[] sortArray(int[] nums) {
        heap = nums;
        for(int i = heap.length / 2; i >= 0; i--){
            heapify(i, heap.length);
        }
        for(int i = heap.length - 1; i >= 0; i--){
            int exc = heap[i];
            heap[i] = heap[0];
            heap[0] = exc;
            heapify(0, i);
        }
        return heap;
    }

    public void heapify(int i, int len){
        int max = i;
        if(2 * i + 1 < len && heap[2 * i + 1] > heap[i]){
            max = 2 * i + 1;
        }
        if(2 * i + 2 < len && heap[2 * i + 2] > heap[max]){
            max = 2 * i + 2;
        }
        if(max != i){
            int exc = heap[max];
            heap[max] = heap[i];
            heap[i] = exc;
            heapify(max, len);
        }
    }
}
```
## 分析
优先队列是一个被很多算法题目涉及到的数据结构，而大根堆与小根堆事实上已经实现了优先队列的操作。在 java 中提供了这一数据结构，你可以直接使用 priorityQueue 来找到它

优先队列可以在 O(lgn) 的时间复杂度下执行删除并返回队列中的最大值、插入一个值，优先队列的查找最大值操作是常数时间的

堆排序的时间复杂度很好理解，同时因为没有开辟新的内存空间，空间复杂度为1

# 归并排序
这个排序需要使用与问题规模相当的地址空间，所以它是非原址排序，这个排序是稳定排序

原址排序基本上不需要额外的空间，也就是允许少量额外的辅助变量

稳定排序是指：如果排序过程中出现了两个相同的元素，那么在输入数组中先出现顺序与在输出数组中出现顺序一致
## 算法思想
归并排序利用了分治的思想来对序列进行排序。对一个长为n的待排序的序列，我们将其分解成两个长度为n/2的子序列。每次先递归调用函数使两个子序列有序，然后我们再线性合并两个有序的子序列使整个序列有序
```java
class Solution {
    int[] tmp;

    public int[] sortArray(int[] nums) {
        tmp = new int[nums.length];
        mergeSort(nums, 0, nums.length - 1);
        return nums;
    }

    public void mergeSort(int[] nums, int l, int r) {
        if (l >= r) {
            return;
        }
        int mid = (l + r) >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1;
        int cnt = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                tmp[cnt++] = nums[i++];
            } else {
                tmp[cnt++] = nums[j++];
            }
        }
        while (i <= mid) {
            tmp[cnt++] = nums[i++];
        }
        while (j <= r) {
            tmp[cnt++] = nums[j++];
        }
        for (int k = 0; k < r - l + 1; ++k) {
            nums[k + l] = tmp[k];
        }
    }
}
```

# 快速排序
快速排序通常是实际应用中最好的选择，但是所有的排序算法都有用，程序员需要判断在哪些环境下该使用何种算法
## 算法思想
1，从数列中挑出一个元素，称为基准
2，重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
3，递归地把小于基准值元素的子数列和大于基准值元素的子数列排序
```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }

    void quickSort(int[] nums, int left, int right){
        if(right > left){
            int p = partition(nums, left, right);
            quickSort(nums, left, p - 1);
            quickSort(nums, p + 1, right);
        }
    }

    int partition(int[] nums, int left, int right){
        int p = left;
        int sign = left + 1;
        for(int i = left + 1; i <= right; i++){
            if(nums[i] < nums[p]){
                int exc = nums[i];
                nums[i] = nums[sign];
                nums[sign] = exc;
                sign++;
            }
        }
        int exc = nums[p];
        nums[p] = nums[sign - 1];
        nums[sign - 1] = exc;
        return sign - 1;
    }
}
```
## 分析
快排的运行时间取决与划分是否平衡，当划分的子问题分别包含 n-1 个元素和0个元素时，可以得出最坏的时间复杂度为 O(n^2)。反之划分的子问题都将近 n/2 时，可以使用递归式推出最优解为 O(n ^2)

事实上，快排的时间复杂度更接近最好情况。就算每次划分都产生9：1的划分，得出递归式如下：
```
T(n) = T(9*n/10) + T(n/10) + cn
```
得出深度为 lgn，每层代价最大为 cn，算出复杂的依然是 O(nlgn)，虽然这种划分直观上看非常不平衡，但是只要随便计算一下就知道快排算法的优点了

同时我们得出结论：**任何一种常数比例的划分都会产生深度为 lgn 的递归树，其中每一层的时间代价都是 O(n)，算法的复杂度都是 O(nlgn)**

可能有些同学对空间复杂度为 logn 表示疑惑，我们明明没有使用额外的内存空间啊，网上的解释是这样的：快排并没有开辟空间，但是使用了递归，递归会开辟栈帧，递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度

每次递归所需要的空间大小都是一样的而且就算是第 N 次递归，每次递归所需的栈空间也是一样的，所以每次递归中需要的空间是一个常量，并不会随着 n 的变化而变化，每次递归的空间复杂度就是1

每次递归所需的空间都被压到调用栈里（压栈），所以快速排序的空间复杂度就是递归算法的空间复杂度 = 每次递归的空间复杂度1*logn = logn
## 优化
我们通过在算法中引入随机性，以此获得较好的期望性能，省去一堆有关概率的数学证明，得出E[X] = O(nlgn)

在上面的代码中我们将最左边的值作为基准，只要将这个值改成使用java语言提供的随机性函数来找到的值为基准即可
# 线性时间排序
基于比较的排序算法的最坏情况下的最优下界是 O(nlogn)，我的另一篇博客已经介绍了这个问题。接下来让我们关注一下线性排序
## 计数排序
计数排序的使用条件是已经知道了数据的范围，它假设n个输入元素中的每一个都在0到k之间，利用这一消息，我们直接将x放在输出数组的对应位置上即可。我们需要一个大小为thetak的空间，排序的时间复杂度为O(n)

## 基数排序
原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

MSD：先从高位开始进行排序，在每个关键字上，可采用计数排序
LSD：先从低位开始进行排序，在每个关键字上，可采用桶排序
### 算法思想
1，将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
2，从最低位开始，依次进行一次排序
3，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列

注意，因为每一个位数只有有限个可能的取值，因此它对位数排序时只要使用计数排序即可。此外，由于存放每一排序结果的桶不是原址的，因此在空间资源比较宝贵的情况下不宜使用
## 桶排序
桶排序或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后依次把各个桶中的记录列出来记得到有序序列

# 顺序统计量
在各大刷题网站以及面试中频繁出现的题目，选出一组数列中第i大的元素，事实上是顺序统计量问题

在一个由n个元素构成的集合中，第i个顺序统计量是该集合中第i小的元素，而一个中位数是一个集合的中点元素

我们找出一个数组中的最大值和最小值只需要遍历一遍即可，时间复杂度为O(n)。但找出一个数组中的某个顺序统计量看起来比找出最大值要难的多，令人惊奇的是两个问题的解决方法的时间复杂度是一致的

## 期望为线性时间的解法
该方法引用了快排思想，快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        randomizedSelected(arr, 0, arr.length - 1, k);
        int[] vec = new int[k];
        for (int i = 0; i < k; ++i) {
            vec[i] = arr[i];
        }
        return vec;
    }

    private void randomizedSelected(int[] arr, int l, int r, int k) {
        if (l >= r) {
            return;
        }
        int pos = randomizedPartition(arr, l, r);
        int num = pos - l + 1;
        if (k == num) {
            return;
        } else if (k < num) {
            randomizedSelected(arr, l, pos - 1, k);
        } else {
            randomizedSelected(arr, pos + 1, r, k - num);
        }
    }

    // 基于随机的划分
    private int randomizedPartition(int[] nums, int l, int r) {
        int i = new Random().nextInt(r - l + 1) + l;
        swap(nums, r, i);
        return partition(nums, l, r);
    }

    private int partition(int[] nums, int l, int r) {
        int pivot = nums[r];
        int i = l - 1;
        for (int j = l; j <= r - 1; ++j) {
            if (nums[j] <= pivot) {
                i = i + 1;
                swap(nums, i, j);
            }
        }
        swap(nums, i + 1, r);
        return i + 1;
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
接下来证明一下该算法的时间复杂度为O(n)

因为我们引入了随机化函数，因此抽到每一个元素的概率为1/n

如果该数组中所有元素都是互异的，该元素执行一遍后在数组中的期望位置为E[X] = n/2 (E[X] = (0 + 1 + .... + n-1) / n)

递归调用，每次算出的期望都在中心点，因此总代价期望相加为E[T(n)] = cn + cn/2 + cn/4 + ... + 1 = O(n)

## 最坏为线性时间的解法
先说算法：

1，将输入数组的n个元素划分为Ln/5」,每组5个元素，且至多只有一组由剩下的n mod 5 个元素组成

2，寻找个组中的每一组的中位数。首先对每组中的元素进行插入排序，然后从排序过的序列中找出中位数。

3，对第2步中找出的个中位数，递归调用SELECT以找出其中中位数 x

4，利用修改过的PARTITION过程，按中位数的中位数x对输入的数组进行划分，让k比划分低区的元素数目多1，所以x是第k小的元素，并且有n-k个元素在划分的高区

5，如果i=k,则返回x；否则，如果i<k,则在低区递归调用SELECT以找出第i小的元素；如果i>k，则在高区中找第(i-k)个最小元素

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/6d733f3eb7caf1f2063bf0b6be4e6699.png)
上图说明了在执行一次后的情况，阴影部分表示了比x大的元素，其他部分是比x小的元素，在第二次执行SELECT时，递归调用最多作用于7n/10+6个元素。通过递归式计算得出该算法最坏时间复杂度为线性时间（假设每一次只消除3n/10的元素，列出递归式T(n) = T(n/5) + T(7n/10) + f(n)，因为1/5 + 7/10填不满1，由微积分可知递归的下一层问题规模一定越来越小，并且所有层数代价加起来小于2f(n)，因此解为O(n)）