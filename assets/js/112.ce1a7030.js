(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{470:function(s,n,a){"use strict";a.r(n);var t=a(15),e=Object(t.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h2",{attrs:{id:"基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[s._v("#")]),s._v(" 基本概念")]),s._v(" "),n("p",[s._v("什么是版本控制系统？\n版本控制是用某种方法来保存某一时刻的文件版本的系统。")]),s._v(" "),n("p",[s._v("版本控制工具的分类？\n一般分为集中式（代表为SVN）和分布式（git）。\n集中式特点为只有一个远程中央仓库来存放所有版本数据，万一远程仓库挂了所有人都不能使用仓库了。\n分布式特点为包括远程仓库的所有人都会保存一份所有版本的数据，在每个人的计算机上的仓库叫本地仓库，远程仓库挂了本地仓库也可以工作。（那么问题来了，怎样保证每一个仓库的同步呢？）")]),s._v(" "),n("p",[s._v("git是什么？\ngit是分布式版本控制工具。\ngit有一个充当中央管理器的地方，客户端并不只提取中央管理器最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。")]),s._v(" "),n("p",[s._v("git与SVN的主要区别？\ngit使用直接记录快照方式进行代码存放，而其他的工具多数使用差异比较的方式")]),s._v(" "),n("p",[s._v("记录快照：对每一个版本都进行存储，并记录指向文件的指针，读取版本时寻找对应版本指针即可\n差异比较：记录初始文件，之后的修改进行增量记录，读取对应版本时必须从最开始读，一条一条向后修改")]),s._v(" "),n("h2",{attrs:{id:"通用-ssh-拉取代码"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通用-ssh-拉取代码"}},[s._v("#")]),s._v(" 通用 ssh 拉取代码")]),s._v(" "),n("p",[s._v("https://blog.csdn.net/qq_38232816/article/details/112822309")]),s._v(" "),n("h2",{attrs:{id:"git-的区域与状态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git-的区域与状态"}},[s._v("#")]),s._v(" git 的区域与状态")]),s._v(" "),n("p",[s._v("工作区：可以在工作区写代码，对应已修改状态\n暂存区：临时存放代码的地方，对应已暂存状态\n本地库：在git仓库中产生对应的历史版本，对应已提交状态\n远程库：代码托管中心，基于网络服务器远程代码仓库")]),s._v(" "),n("h2",{attrs:{id:"分支开发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#分支开发"}},[s._v("#")]),s._v(" 分支开发")]),s._v(" "),n("p",[s._v("也是之前那个问题的答案（怎样保证每一个仓库的同步）")]),s._v(" "),n("p",[s._v("git最大的特点是分支开发，将远程仓库中的主代码copy下来，如果要修改代码或者写代码，就切换分支或者创建分支，在该分支中进行业务开发，如果要将代码提交，可以提交到仓库的对应分支中，或者进行分支合并再提交")]),s._v(" "),n("p",[s._v("一般来说，先在自己的分支上开发，然后切换到主分支拉取远程代码，并且合并分支")]),s._v(" "),n("p",[n("strong",[s._v("切换分支时")]),s._v("，IDEA当在一个分支上修改了内容没有提交，然后切换到其他分支时，这时IDEA会弹出提示，问你要选择Smart Checkout还是Force Checkout：")]),s._v(" "),n("p",[s._v("如果想保留你在原分支上的修改内容，那么选择Smart Checkout；而 Force Checkout不会保留你的修改，切到另一个分支内容就消失了，且切回来原来分支也找不回")]),s._v(" "),n("p",[s._v("而 merge into curren 的作用是将所选分支合并到当前分支")]),s._v(" "),n("h2",{attrs:{id:"代码回滚"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码回滚"}},[s._v("#")]),s._v(" 代码回滚")]),s._v(" "),n("p",[s._v("git reset 命令用于回滚代码到某次提交之前，该命令是用来回退版本的，git reset 三种模式分别为 : mixed(默认)、soft、hard")]),s._v(" "),n("p",[s._v("--hard : 回退版本库，暂存区，工作区到指定 commit。因此我们修改过的任何代码就没了")]),s._v(" "),n("p",[s._v("--mixed: 回退版本库，暂存区。--mixed为git reset的默认参数，即当任何参数都不加的时候的参数。此时工作区的代码不受影响，但是你可能观察到有些类变红了或者变蓝了，这就是工作区的代码与版本库代码不一致导致的")]),s._v(" "),n("p",[s._v("--soft: 只回退版本库")]),s._v(" "),n("p",[s._v("git 还提供了一个代码回滚命令：git revert。该命令用于反做。使用 reset 命令，Git 会把要回退版本之后提交的修改都删除掉。要从第四次修改回退到第一次修改，那么会删除第二、三、四次的修改")]),s._v(" "),n("p",[s._v("那如果发现第三次修改有错误，想要恢复第三次修改，却要保留第四次修改呢？这个时候就可以用 revert 命令：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('git revert -n 97ea0f9\ngit commit -m "恢复第三次修改"\n\n-- 回滚到8个版本之前\ngit revert HEAD~8..HEAD\n\n-- m 1表示保留当前分支的更改，m2 表示保留另外一个分支的修改\ngit revert -n 97ea0f9 -m 1\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("git 的提交历史为")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('33b8b30 (HEAD -> master) Revert "恢复第三次修改"\n42eae13 第四次修改\n97ea0f9 第三次修改\ne50b7c2 第二次修改\n3a52650 第一次修改\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[s._v("注意，git revert 可以回滚多次提交的代码。每次使用 git revert 命令可以撤销指定的提交，如果需要撤销多次提交，则需要多次执行 git revert 命令。每次执行 git revert 命令都会生成一个新的提交，用于撤销之前的提交")]),s._v(" "),n("p",[s._v("在实际生产环境中，代码是基于 master 分支发布到线上的，会有多人进行提交。可能会碰到自己或团队其他成员开发的某个功能在上线之后有 Bug 需要及时做代码回滚的操作")]),s._v(" "),n("p",[s._v("在确认要回滚的版本之后，如果别人没有最新提交，那么就可以直接用 reset 命令进行版本回退，否则，就可以考虑使用 revert 命令进行还原修改，不能影响到别人的提交")]),s._v(" "),n("p",[s._v("使用 reset 还是 revert，需要考虑实际的适用场景，没有绝对化")]),s._v(" "),n("h2",{attrs:{id:"常用的命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用的命令"}},[s._v("#")]),s._v(" 常用的命令")]),s._v(" "),n("div",{staticClass:"language-linux line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("head表示指针，使用HEAD可以代表当前分支\nHEAD\n代表上一个版本\nHEAD~\n一般开发流程\n将远程仓库clone到本地，创建新分支（master不一定有权限），add、commit、push，在发布时会将dev分支合并到master分支并且发布master分支。如果提交不了可能是远程仓库有更新或者dev分支与mas分支有冲突，拉取之后用marge合并即可\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[s._v("如何开始")]),s._v(" "),n("div",{staticClass:"language-linux line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("在当前文件夹下初始化本地库\ngit init\n克隆一个已存在的远程仓库，git clone -b dev 加远程链接会拉取一个指定分支并关联\ngit clone\n管理远程仓库相关操作，关联仓库使用add，获取更多帮助使用--help\ngit remote\n拉取远程分支并创建本地同名分支\ngit checkout -b 本地分支名x origin/远程分支名x\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("div",{staticClass:"language-linux line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('查看本地库以及代码状态\ngit status\n查看历史版本，只记录已经提交的版本\ngit log\n查看历史版本，记录该分支下所有操作\ngit reflog\n\n添加文件到暂存区\ngit add\n比较文件的不同，默认比较工作区与暂存区的不同，后加cached或者staged可比较暂存区与本地仓库的不同，也可以比较不同分支的差异\ngit diff\n提交本地库，一般使用-am，因为该命令提交已追踪的文件，比较方便\ngit commit -m "日志信息" 文件名\n远程仓库推送，一般来说，要先进行创建分支或者分支合并操作，如果远程分支与本地分支名字相同，可省略冒号以及后面内容\ngit push <远程主机名> <本地分支名>:<远程分支名>\n\n从远程仓库拉取代码相关\n从远程仓库拉取代码，用该命令拉取分支会放到origin:dev中，就算已经处于dev分支也需要进行代码合并\ngit fetch \n分支合并操作，可以后跟两个分支将两个分支合并，也可以后加一个分支将目前分支与该分支合并；merge也可以用来处理冲突\ngit merge\n拉取代码并且合并操作，相当与执行了上面两个代码\ngit pull\n\n该命令用来管理分支，默认执行查看所有分支，后加一个分支名用来新建分支，后加-d可用来删除分支\ngit branch\n该命令用来切换分支，默认执行后跟分支名可切换分支，后加-b加分支名新建分支并且切换分支\ngit checkout\n创建一个新分支并且切换过去，后面的origin是一个远程仓库名，/dev指的是仓库下的某个分支名，接着将新建的这个分支与远程的dev分支联系起来\ngit checkout -b dev origin/dev\n\n重置代码到之前的版本，其中默认为--mixed，还有--hard以及--soft\ngit reset\n撤销已经存在的提交\ngit revert\n将一个分支与另一个分支线性合并\ngit rebase\n\n删除暂存区文件\ngit rm --catched 文件名\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br")])]),n("p",[s._v("如果出现了一些奇怪的提示，使用这个\ngit pull test master --allow-unrelated-histories")])])}),[],!1,null,null,null);n.default=e.exports}}]);