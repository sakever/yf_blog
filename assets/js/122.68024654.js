(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{485:function(s,t,p){"use strict";p.r(t);var o=p(15),a=Object(o.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("Gossip 算法是一种在分布式系统中广泛使用的通信协议，主要用于信息传播和状态同步。Gossip 算法通过节点之间随机的、周期性的信息交换，实现信息的高效传播和系统的最终一致性")]),s._v(" "),t("p",[s._v("之前以为 Gossip 是分布式一致性算法，后来了解到不是，它是通信协议，因此将该内容从之前的博客中拆出来了")]),s._v(" "),t("h2",{attrs:{id:"协议介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议介绍"}},[s._v("#")]),s._v(" 协议介绍")]),s._v(" "),t("p",[s._v("Gossip 协议如其名，在办公室，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名，如“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。但 Gossip 并不是一个新东西，之前的泛洪查找、路由算法都归属于这个范畴，不同的是 Gossip 给这类算法提供了明确的语义、具体实施方法及收敛性证明")]),s._v(" "),t("p",[s._v("Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机地与其它节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其它节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终它们的状态都是一致的")]),s._v(" "),t("p",[s._v("要注意到的一点是，即使有的节点因宕机而重启，有新节点加入，但经过一段时间后，这些节点的状态也会与其他节点达成一致，也就是说，Gossip 天然具有分布式容错的优点")]),s._v(" "),t("h2",{attrs:{id:"协议流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议流程"}},[s._v("#")]),s._v(" 协议流程")]),s._v(" "),t("p",[s._v("1，初始化：每个节点维护一个状态表，记录自身的状态和其他节点的状态\n2，消息生成：因为业务原因，节点生成包含自身状态的消息\n3，消息传递：节点随机选择一个或多个其他节点，将消息发送给这些节点\n4，消息接收：节点接收到消息后，更新自己的状态表，合并新收到的信息\n5，周期性重复：这个过程周期性地重复，直到所有节点的状态达到最终一致性")]),s._v(" "),t("h2",{attrs:{id:"缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" 缺点")]),s._v(" "),t("p",[s._v("分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：")]),s._v(" "),t("p",[s._v("1，消息的延迟：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下")]),s._v(" "),t("p",[s._v("2，消息冗余：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余")])])}),[],!1,null,null,null);t.default=a.exports}}]);