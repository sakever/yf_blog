(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{476:function(s,a,t){"use strict";t.r(a);var n=t(15),r=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("算法是处理数据的计算过程，在计算中明智的使用时间、空间等资源")]),s._v(" "),a("p",[s._v("数据结构是储存数据的方式，主要目的是为了满足占用空间、查找速度、插入速度中的一部分")]),s._v(" "),a("h2",{attrs:{id:"循环不变式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环不变式"}},[s._v("#")]),s._v(" 循环不变式")]),s._v(" "),a("p",[s._v("从一道有趣的题目开始")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("布口袋中有黑，白两色小球，现将手放入袋中每次摸出两个，如果两球同\n色就都不放回袋中，如果两球异色就将白球放回，由于每次至少减少一\n个，所以袋中的球必然越来越少。现问"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("如果袋中最后剩下一个球，此球\n的颜色与开始时袋中黑、白球的个数有什么关系？按照一般的思路，此题\n非常复杂，难以解决。多次重复摸球及放回的动作构成了一个循环过程。\n如果我们有意识地寻找循环过程中不变的性质，就会发现"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("在循环过程中"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n白球个数的奇偶性保持不变"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("因为"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("每次取出的白球的个数或是零或是"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2.")]),s._v("因\n此"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("如果开始时白球的个数为奇数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("那么剩下的一球为白球。如果开始时白\n球的个数为偶数，那么剩下的一球为黑球\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("循环不变式的作用是让我们理解并且"),a("strong",[s._v("证明")]),s._v("算法的正确性（因为程序只要不是O(1)的，都可以看做循环的变种）")]),s._v(" "),a("p",[s._v("循环不变式总的来说是一个判断语句，她的主要性质如下：")]),s._v(" "),a("p",[s._v("1，初始化：在循环开始之前，循环不变式判断为true\n2，保持：在一次迭代的前后，她都判断为true\n3，终止：在循环终止时，不变式为我们提供一个有用的性质")]),s._v(" "),a("p",[s._v("举几个例子：\n1，在算法导论中，插入排序的循环不变式为数组A[1,...,j]都是已经排好序的数组，在开始到结束都满足这个性质\n2，题目2.1-3，循环不变式为A[1,...,j]中都不包含val\n3，在上面那道有趣的题目中，循环不变式为白球个数的奇偶性保持不变")]),s._v(" "),a("h2",{attrs:{id:"求解递归式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#求解递归式"}},[s._v("#")]),s._v(" 求解递归式")]),s._v(" "),a("p",[s._v("当一个函数包含对其自身的调用时，我们就可以使用一个递归式来表示，例如：\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/df53411674eafd4f80ed2a58ab6754de.png",alt:"在这里插入图片描述"}}),s._v("\n那么如何算出形如该函数的时间复杂度呢，算法导论给出了三个方法：主方法、递归树法、代入法")]),s._v(" "),a("h3",{attrs:{id:"代入法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代入法"}},[s._v("#")]),s._v(" 代入法")]),s._v(" "),a("p",[s._v("根据过往的经验来猜测递归式的解O(x)，同时，如果可以寻找一个数c，证明T(x) <= cO(x)，则可以确定界")]),s._v(" "),a("p",[s._v("例如：T(n) = 2T(n/2)+n，我们猜测解是O(nlgn)\n代入可知T(n) <= 2c(n/2)lg(n/2)+n <= cnlgn-cnlg2+n = cnlgn-cn+n\n因此T(n) <= O(nlgn)，所以我们的猜测成立")]),s._v(" "),a("h3",{attrs:{id:"递归树法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归树法"}},[s._v("#")]),s._v(" 递归树法")]),s._v(" "),a("p",[s._v("将递归式转化为树形结构，树中的结点代表在不同递归层次付出的代价，最后利用对和式限界的技术来解出递归式")]),s._v(" "),a("p",[s._v("在第二章分析分治算法的时候就用到了递归树法，比如求解下面递归式\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/cfb13fff6d991e8dadfc0776048c9ce1.png",alt:"在这里插入图片描述"}}),s._v("\n画出图像：\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/bc694b9857e92d1ce51ff745d81ce3d1.png",alt:"在这里插入图片描述"}}),s._v("\n每一层每个节点的数字代表了执行此函数使用的代价，而右边代表了这一层的总代价，将右边每一层代价加起来就找到了这个递归树的总代价")]),s._v(" "),a("p",[s._v("注意，最后一层的时间复杂度是常数，所以只要计算出有多少的节点就行，因为树的深度为log4n，每层数目是上层的三倍，所以得出nlog43\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/2e681cc6189a7de28eeff4ecc075c124.png",alt:"在这里插入图片描述"}}),s._v("\n我们通过找规律就能直接得出这个公式，甚至可以把公式背下来（就是下面介绍的主方法），很多情况下通过递归树是解决不了问题的。做过后面练习题就知道，最后的解会出现形如3^(lgn+1)这种鬼东西，完全没有意义")]),s._v(" "),a("p",[s._v("因此在求解之前，需要先进行缩放，我们可以以此来确定解的上界或者下界")]),s._v(" "),a("p",[s._v("对T(n) = T(n/3) + T(2*n/3) + O(n)，时间复杂度是nlgn\n对T(n) = T(n/2) + O(n ^ 2)，时间复杂度为 n ^ 2")]),s._v(" "),a("h3",{attrs:{id:"主方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主方法"}},[s._v("#")]),s._v(" 主方法")]),s._v(" "),a("p",[s._v("主方法是一个公式，形如T(n) = a * T(n/b) + f(n)的递归式都可以使用主方法求解")]),s._v(" "),a("p",[s._v("主方法原理式使用递归树解出适用于任意a、b和f(n)的统一解，计算所有中间结点和叶子结点的代价和，推导出简单的结果\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/9d057c8f50e6c8e5cf38b088179f8002.png",alt:"在这里插入图片描述"}}),s._v("\n图中说总代价等于一个奇怪的玩意，但是先辈们已经将这个结论简化了，他们发现上层代价与底层总代价的大小关系决定了递归式的解，因此只要直接记住结论即可，我们记中间累加式为g(n)：\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/08322d9da20276a5f3ab3155da7b562c.png",alt:"在这里插入图片描述"}})]),s._v(" "),a("p",[s._v("1，如果底层代价较大的话，g(n)以及递归式的解就为底层代价"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/a5ed95ce12fa9b3b5dfac6af3c96fd45.png",alt:"在这里插入图片描述"}})]),s._v(" "),a("p",[s._v("2，如果两个一样大，g(n)为底层代价乘lgn"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/47262fd8b85e44e176ce04979d058acf.png",alt:"在这里插入图片描述"}}),s._v("\n3，如果f(n)比较大，即上层的代价大的话，需要满足对于某个常数c<1和所有足够大的n满足如下公式\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/5aaeeace15ba570304c4e0d057d6d397.png",alt:"在这里插入图片描述"}}),s._v("\n此时，可以得出\n"),a("img",{attrs:{src:"https://i-blog.csdnimg.cn/blog_migrate/fd3bd0dfae0015cad14f06a3dee38d51.png",alt:"在这里插入图片描述"}})]),s._v(" "),a("h2",{attrs:{id:"渐进符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渐进符号"}},[s._v("#")]),s._v(" 渐进符号")]),s._v(" "),a("p",[s._v("我们在算法书上最常见的是Θ符号（读作/ˈθiːtə/，theta），它定义了上界和下界，f(n)位于上界和下界之间，且包含等号，使用官方语言说是：")]),s._v(" "),a("p",[a("code",[s._v("若存在正常数c1、c2,使得对于足够大的n, f (n)能“夹入”c1g(n)和c2g(n)之间，则f (n)属于集合Θ（g(n)）")])]),s._v(" "),a("p",[s._v("其他四个分别是：\nO，大Oh，定义了函数的上界，不定义函数的下界；\no，小Oh，定义了函数的上界，不过它不包含等于，是一种不精确的上界，比如：2n = o(n^2)，2n != o(n)；\nΩ，大Omega，定义了函数的下界，不定义函数的上界；\nω，小Omega，同样定义的是下界，只不过不包含等于，是一种不精确的下界")]),s._v(" "),a("p",[s._v("但是，平时我们使用的最多的却是O。因为在有些场景Θ是不正确的，描述算法时，算法的最好复杂度可能低于这个界，例如插入排序的时间复杂度是O(N ^ 2)而不是Θ(N ^ 2)，因为其最好时为Θ(N)")]),s._v(" "),a("h2",{attrs:{id:"优雅的写法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优雅的写法"}},[s._v("#")]),s._v(" 优雅的写法")]),s._v(" "),a("p",[s._v("收录在第一部分遇到的题目的简洁而易读的写法")]),s._v(" "),a("h3",{attrs:{id:"多重判断拆分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多重判断拆分"}},[s._v("#")]),s._v(" 多重判断拆分")]),s._v(" "),a("p",[s._v("某些问题需要进行嵌套判断，寻找到一些可以移除的性质一层一层进行处理")]),s._v(" "),a("p",[s._v("eg：\n考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个（n+1）元数组C中")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ADD")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("BINARY")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("C")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n\n  carry "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("to")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("length\n      "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("C")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" carry"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("%")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// remainder")]),s._v("\n      carry "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" carry"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// quotient")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("C")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" carry\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("C")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h3",{attrs:{id:"哨兵牌"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵牌"}},[s._v("#")]),s._v(" 哨兵牌")]),s._v(" "),a("p",[s._v("为了避免在一些判断，我们在适当的时候加入哨兵牌，它包含一个特殊的值，用于简化代码")]),s._v(" "),a("p",[s._v("eg：\n合并两个已排序的子序列以产生已排序的新序列")]),s._v(" "),a("p",[s._v("这里我们使用∞作为哨兵值，结果每当显露一张值为∞的牌，它不可能为较小的牌，除非两个序列都已经显露出其哨兵牌")])])}),[],!1,null,null,null);a.default=r.exports}}]);